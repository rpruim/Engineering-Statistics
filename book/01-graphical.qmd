---
fig-height: 2.5
---

# Graphical Summaries of Data

```{r}
#| label: setup-graphical
#| include: false
library(ggformula)
library(mosaic)
library(readr)
library(alr4)
library(DAAG)
library(palmerpenguins)
theme_set(theme_bw(base_size = 14))
```


## Getting Started With RStudio 

![Welcome to RStudio](images/RStudio-Welcome.png)



RStudio  is an integrated development environment (IDE) for R 
a freely available language and environment for statistical computing and graphics.
Both are freely available for Mac, PC, and Linux.

In addition to running RStudio  on your local machine, you have the option
of accessing an RStudio  server via a web browser.  (For best results, avoid 
Internet Explorer.)


### Using R as a calculator

Notice that RStudio  divides its world into four panels.  Several of the panels
are further subdivided into multiple tabs.
The console panel is where we type commands that R will execute. 

R can be used as a calculator.  Try typing the following commands in the console panel.

```{r arithmetic2}
5 + 3
15.3 * 23.4
sqrt(16)
```

You can save values to named variables for later reuse
```{r variables2,tidy = FALSE}
product = 15.3 * 23.4       # save result
product                     # show the result
product <- 15.3 * 23.4      # <- is assignment operator, same as =
product
15.3 * 23.4 -> newproduct   # -> assigns to the right
newproduct
.5 * product                # half of the product
log(product)                # (natural) log of the product
log10(product)              # base 10 log of the product
log(product, base = 2)        # base 2 log of the product
```


The semi-colon can be used to place multiple commands on one line.
One frequent use of this is to save and print a value all in one go:
```{r variables-semi2,tidy = FALSE}
15.3 * 23.4 -> product; product    # save result and show it
```


### Loading packages

R is divided up into packages.  A few of these are loaded every time you
run R but most have to be selected.  This way you only have as much of R as you
need.

In the **Packages** tab, check the boxes next to the following packages to
load them:
<!-- begin itemize -->

#. mosaic (a package from Project MOSAIC)
#. DAAG  (a package that goes with the book *Data Analysis and Graphic*)

<!-- end itemize -->

You an also load packages by typing, for example
```{r load-package}
library(DAAG)       # loads the DAAG package if it is not already loaded
```


### Four Things to Know About R 

#### 1. R is case-sensitive {-}

If you mis-capitalize something in R it won't do what you want. If you get an error message about an "object not found",
check to see that you spelled it correctly.

#### 2. Functions in R use the following syntax: {-}

```{r }
#| label: function-syntax
#| eval: false
functionname( argument1, argument2, ... )
```

a. The arguments are **always** _surrounded by (round) parentheses_ and _separated by commas_.

b. Some functions (like `data()`) have no required arguments, but you still need the parentheses.

c. If you type a function name without the parentheses, you will see the _code_ for that
function -- which probably isn't what you want at this point.

#### 3. TAB completion and arrows can improve typing speed and accuracy. {-}

If you begin a command and hit the TAB key, R will show you a list of
possible ways to complete the command.  If you hit TAB after the opening
parenthesis of a function, it will show you the list of arguments it expects.
The up and down arrows can be used to retrieve past commands.

#### 4. Hit ESCAPE to break out of a mess. {-}
	
If you get into some sort of mess typing (usually indicated by extra '$+$' 
signs along the left edge, indicating that R is waiting for more 
input -- perhaps because you have some sort of error in what has gone before), 
you can hit the escape key to get back to a clean prompt.


## Data in R 

### Data Frames
Most often, data sets in R are stored in a structure called a 
**data frame**.  A data frame is designed to hold "rectangular data".
The people or things being measured or observed are called 
**observational units** (or subjects or cases when they are people).
Each observational unit is represented by one row. 
The different pieces of information recorded for each observational unit are stored in
separate columns, called **variables**.

### Data in Packages
There are a number of data sets built into R 
and many more that come in various add on packages.

You can see a list of data sets in a particular package like this:
```{r datasets,eval = FALSE}
library(mosaicData)            # load the package
data(package = "mosaicData")   # see what data sets are in it
```


You can find a longer list of all data sets available in any loaded package
using 
```{r eval = FALSE}
data()
```



### The HELPrct data set
The `HELPrct` data frame from the `mosaic` package
contains data from the Health Evaluation and Linkage to Primary Care
randomized clinical trial.  You can find out more about the study and
the data in this data frame by typing
```{r HELPrcthelp,eval = FALSE,tidy = FALSE}
?HELPrct
```


Among other things, this will tell us something about the subjects (observational units) in
this study:

> Eligible subjects were adults, who spoke Spanish or English, reported
alcohol, heroin or cocaine as their first or second drug of choice, resided
in proximity to the primary care clinic to which they would be referred or
were homeless. Patients with established primary care relationships they
planned to continue, significant dementia, specific plans to leave the
Boston area that would prevent research participation, failure to provide
contact information for tracking purposes, or pregnancy were excluded.

> Subjects were interviewed at baseline during their detoxification stay and
follow-up interviews were undertaken every 6 months for 2 years.

It is often handy to look at the first few rows of a data frame.  It will
show you the names of the variables and the kind of data in them:

```{r headHELP}
head(HELPrct)
```


When there are a lot of variables, this format can be hard to read.  The `glimpse()` or `inspect()`
functions provide some other options.

```{r glimpseHELP}
glimpse(HELPrct)
inspect(HELPrct)
```


From this we see that there are `r nrow(HELPrct)` observational
units in this data set and `r ncol(HELPrct)` variables.
That's plenty of variables to get us started with exploration of data.

### The KidsFeet data set
Here is another data set in the `mosaic` package:
```{r }
head(KidsFeet)
```


### The oldfaith data set
A final example data set comes from the `alr4` package.  This package is probably not 
loaded (unless you already loaded it).  You can load it from the **Packages** tab or
by typing the command
```{r }
library(alr4)      # require(alr4) will also work
```

Once you have done that, you will have access to the data set containing information about
Old Faithful eruptions.

:::{.center}

{{< video https://www.youtube.com/embed/Qxf3xzirBrs width="560" height="315" title="Old Faithful">}}

:::

```{r }
head(oldfaith)
```


If you want to know the size of your data set, you can ask it how many rows and columns it has
with
`nrow()`, `ncol()`, or `dim()`:
```{r }
nrow(oldfaith)
ncol(oldfaith)
dim(oldfaith)
```

In this case we have 270 observations of each of two variables (the length of an eruption and the time until 
the next eruption).
In a data frame, the observational units are always in the rows and the variables
are always in the columns.  If you create data for use in R (or most other 
statistical packages), you need to make sure your data are also in this shape.

### Using your own data

In the Environment tab you will "Import Dataset".  Click on this import data 
from a CSV file, Excel spreadsheet, or a few other formats.  When you 
do this, the R code will be displayed, so you can see how it is done in 
R code.

If you are using the RStudio server, you will first need to upload your file to the server (unless you can
access the file via URL).  To do this, choose "Upload" from the Files tab.


## Graphical and Numerical Summaries of Data

### The Most Important Template

Using the `mosiac` and `ggformula` packages, 
we can compute a wide variety of graphical and numerical summaries 
using the following general template:

:::{boxedText}

![The most important template](images/most-important-template.png){width='75%'}
:::

We will see this same template used again for linear and non-linear 
modeling as well, so it is is important to master it.^[This is textbook speak for "you should really 
take note of this -- probably memorize it."]

* `goal`: The name of the function generally describes your goal, 
		the thing you want the computer to produce for you.  In the case of plotting,
		it is the name of the plot.  When we do numerical summaries it will be the 
		name of the numerical summary (mean, median, etc.).
* `y`: For plots, this is the variable that goes on the y-axis. 
* `x`: For plots, this is the variable that goes on the x-axis. 
* `formula`: Together, `y ~ x` is called a **formula**.
		Very often we can think of `y ~ x` as "y depends on x".
		We will see that sometimes we can omit `y` ore replace `x` with `.` (there must
		always be something on the right-hand side).  We will even see things like 
		`y ~ x | z`.  But the most important formula to learn is `y ~ x`.
* `mydata:` A data frame must be given in which the variables mentioned in
		the formula can be found.  Variables not found there will be looked for in the 
		enclosing environment.  Sometimes we will take advantage of this to avoid creating
		a temporary data frame just to make a quick plot, but generally it is best to have
		all the information inside a data frame.


## Scatterplots

The most common way to look at two quantitative variables is with a 
scatter plot.  The `ggformula` function for this is `gf_point()`, 
and the basic syntax is

```{r xyplot-syntax, eval = FALSE}
gf_point( yvar ~ xvar, data = dataName)
```


Let's look at an example. Let's see how bill length is related to body mass in some penguins.

```{r tidy = FALSE}
#| label: fig-gf-point
#| fig-cap: A scatter plot of penguin data.
#| out-width: 60%
library(palmerpenguins)
head(penguins) 
gf_point(bill_length_mm ~ body_mass_g, data = penguins)
```


That's all there is to it.  We can replace `bill_length_mm`, `body_mass_g`, and 
`penguins` with any variables and data set we like to get the scatter plot we want.

### Adding Color

Let's add some color. Consider the next two examples.

```{r }
#| label: fig-mapping-and-setting-color
#| layout-ncol: 2
#| fig-cap: 
#|   - "Setting color"
#|   - "Mapping color"
gf_point(bill_length_mm ~ body_mass_g, color = "navy", data = penguins)
gf_point(bill_length_mm ~ body_mass_g, color = ~ species, data = penguins)
```

<!-- begin itemize -->

* In the first we are **setting** the color of the dots to be navy.
* In the second, we are **mapping** color based on `species`.
Think of `color = ~ species` as "color depends on  species".
<!-- end itemize -->

The warnings, by the way, are indicating that two rows of data were not used in making the plot
because they were missing data needed for the plot (either `bill_length_mm` or `body_mass_g`).

```{r}
#| code-fold: true
# This is a bit of bonus code, 
# in case you are interested to see how we find these two penguins.
penguins |> 
  filter(is.na(bill_length_mm) | is.na(body_mass_g))
```

### Transparency and dot size

With so much data in so little space, overplotting (dots on top of each other) can make 
it hard to see what is going on. We can improve this plot by making the dots smaller
and semi-transparent.

```{r }
#| label: transparency-and-dot-size
#| fig-width: 5
#| fig-cap: "Adjustments to `alpha` and `size`."
gf_point(bill_length_mm ~ body_mass_g, 
         color = ~ species, data = penguins,
         size = 0.8, alpha = 0.6)
```


There are many other options we can use to refine our plots.  We'll learn about some of them as we 
go along. You can use R 's built-in help to find out more.  Our you can type

```{r quick-help}
gf_point()
```


### Conditional plots (aka Faceting)

The formula for a `ggformula` plot can be extended to create multiple
panels, called facets, based on a "condition", often given by another variable. 
The  general syntax for this becomes
```{r eval = FALSE}
plotname( y ~ x | condition, data = dataName )
```


You can read the formula `y ~ x | condition` as saying that we want to know how y depends on x separately
for each condition.
In our penguins example, we might divide up the data according to the islands on which the penguins were spotted.

```{r }
#| label: fig-facets
#| fig-cap: Using facets to separate the species.
#| out-width: 50%
gf_point(bill_length_mm ~ body_mass_g | island, 
         color = ~ species, data = penguins,
         size = 0.8, alpha = 0.5)
```


### Other types of plots

A scatter plot will be our most common plot for two quantitative variables, but we can use the same
template for any other type of plot.  Here are two examples.

```{r }
#| label: fig-penguins-more
#| layout-ncol: 2
#| fig-cap: More plots of penguins.
#| fig-subcap: 
#|   - A 2-d density plot.
#|   - A hex plot.
gf_density2d(bill_length_mm ~ body_mass_g, color = ~ species, data = penguins, alpha = 0.5)
gf_hex(bill_length_mm ~ body_mass_g, data = penguins, binwidth = c(250, 2))
```



## Graphing the Distribution of One Variable

A **distribution** is described by telling what values occur 
and with what frequency.  That is, the distribution answers two 
questions:
<!-- begin itemize -->

* What values?
* How often?
<!-- end itemize -->

Statisticians have devised a number of graphs to help us see 
distributions of a variable visually.
In these graphs, R can compute the y-variable for us.  In this case, we simply
omit the `y` part of the formula, so the
general syntax for making a graph or numerical summary
of one variable in a data frame is
```{r eval = FALSE}
plotname( ~ variable, data = dataName )
```

In other words, there are three pieces of information we must provide to 
R in order to get the plot we want:

:::{.enumerate}

1. The **kind of plot**. 
(`gf_histogram()`, `gf_bar()`, `gf_density()`, `gf_boxplot()`, etc.) 

1. The name of the **variable** to plot.

1. The name of the **data frame** this variable is a part of.

:::

Note: The same syntax works for numerical summaries as well -- thanks to the `mosaic`
package we can apply the same syntax for 
		`mean()`, `median()`, `sd()`,
		`var()`, `max()`, `min()`, etc.
		Later we will use this syntax again to compute linear and 
		nonlinear models.

### Histograms (and density plots) for quantitative variables

Histograms (and density plots) are the two most common ways of displaying the distribution 
of a quantitative variable.


Here are a couple examples:

```{r }
#| label: fig-histogram
#| fig-cap: Example histograms.
#| fig-subcap: ""
#| layout-ncol: 2
gf_histogram( ~ Duration, data = oldfaith)
gf_histogram( ~ age, data = HELPrct)
```


In each of these plots the height of the bar indicates how many observations
fall within the range indicated by the bottom of the bar. So in the histogram below,
the red bar indicates that there are almost 60 eruptions of duration between 100 and 125 seconds
in this data set.

```{r }
#| echo: false
#| label: fig-histogram-explained
#| fig-cap: The red bar indicates that there are almost 60 eruptions of duration between 100 and 125 seconds in this data set.
#| fig-width: 6
#| fig-align: center
gf_histogram( ~ Duration, data = oldfaith, binwidth = 25, boundary = 100) |>
  gf_histogram( ~ Duration, data = oldfaith |> filter(Duration >100, Duration <= 125), 
                fill = "red", color = "black", 
                binwidth = 25, boundary = 100) 

```


We can control the (approximate) number of bins using the `bins` argument.
The number of bins (and to a lesser extent the positions of the bins)
can make a histogram look quite different.

```{r}
#| label: fig-histogram2 
#| fig-cap: "Histograms with different numbers of bins."
#| fig-subcap: ""
#| layout-ncol: 3

gf_histogram( ~ Duration, data = oldfaith, bins = 8 )
gf_histogram( ~ Duration, data = oldfaith, bins = 15 )
gf_histogram( ~ Duration, data = oldfaith, bins = 30 )
```



We can use `binwidth` to set the width of the bins.

```{r binwidth}
#| label: fig-histogram3 
#| fig-cap: "Histograms with different bin widths."
#| fig-subcap: ""
#| layout-ncol: 3
gf_histogram( ~ Duration, data = oldfaith, binwidth = 60 )
gf_histogram( ~ Duration, data = oldfaith, binwidth = 20 )
gf_histogram( ~ Duration, data = oldfaith, binwidth = 5 )
```


R also provides a "smooth" version called a density plot and a triangular version
called a frequency polygon:; 

```{r }
#| label: fig-density
#| fig-cap: "Density plots and frequency polygons."
#| fig-subcap: ""
#| layout-ncol: 3
gf_density( ~ Duration, data = oldfaith )
gf_dens( ~ Duration, data = oldfaith )
gf_freqpoly( ~ Duration, data = oldfaith )
```



### Describing the shape of a distribution

If we make a histogram of our data, we can describe the overall shape of the distribution.
Keep in mind that the shape of a particular histogram may depend on the choice of bins.
Choosing too many or too few bins can hide the true shape of the distribution.  (When in doubt, make
more than one histogram.)

Here are some words we use to describe shapes of distributions.

<!-- begin description -->
* **symmetric** The left and right sides are mirror images of each other.
* **skewed** The distribution stretches out farther in one direction than in the other.
(We say the distribution is skewed toward the long tail.)
* **uniform** The heights of all the bars are (roughly) the same.
(So the data are equally likely to be anywhere within some range.)
* **unimodal** There is one major "bump" where there is a lot of data.
* **bimodal** There are two "bumps".
* **outlier** An observation that does not fit the overall pattern of the rest of 
the data.
<!-- end description -->

We'll learn about another graph used for quantitative variables (boxplots)
soon.

### Bar graphs for categorical variables

Bar graphs are a way of displaying the distribution of a categorical variable.

```{r }
#| label: fig-bargraph
#| fig-cap: "Bar graphs"
#| fig-subcap: 
#|   - "vertical bars"
#|   - "horizontal bars"
#| layout-ncol: 2
gf_bar( ~ species, data = penguins)   # vertical bars
gf_bar(species ~ ., data = penguins)  # horizontal bars
```


Statisticians rarely use pie charts because they are harder to read except in a few special cases (like comparing
a proportion to 50%).

### Overlaying and faceting data

Overlaying and faceting work the same for these one variables plots as they did for the scatterplots above.

```{r }
#| label: fig-overlaying-and-faceting
#| fig-cap: "Overlaying and faceting in plots"
#| fig-subcap: ""
#| layout-ncol: 3
gf_bar( ~ species | island, data = penguins)
gf_histogram( ~ body_mass_g | species, data = penguins)
gf_dens( ~ body_mass_g, color = ~ species, data = penguins)
```


For example, we might like to see how the ages of men and women compare 
in the HELP study, or whether the distribution of lengths of boys' feet 
is different from the distribution for girls.

```{r compare-ages}
#| layout-ncol: 2
gf_histogram( ~ age | sex, data = HELPrct, binwidth = 5)
gf_dens( ~ length | sex, data = KidsFeet )
```



We can do the same thing for bar graphs.

```{r }
#| label: fig-substance-by-sex
#| fig-cap: "Facets in a bar graph."
#| out.width: 50%
gf_bar( ~ substance | sex, data = HELPrct)
```


### Grouping and bar charts

When dividing bar charts into multiple colors, we can present the segmented bars "stacked" (the default)
or "dodged":

```{r }
#| label: fig-stack-and-dodge
#| fig-cap: "We can show different groups using stacked or dodged bar graphs."
#| fig-subcap: 
#|   - Stacked bar graph.
#|   - Dodged bar graph.
#| layout-ncol: 2
gf_bar(~substance, fill = ~sex, data = HELPrct)
gf_bar(~substance, fill = ~sex, data = HELPrct, position = "dodge")
```


### Proportions and bar charts

Sometimes it is better to display bars with proportions rather than counts. But then we must decide
what to use for the denominator.
In the first example below, the total of all the bars adds to 1. In the second plot, the total
adds to one for each x variable, which makes it easier to see how the proportions of male and female
.

```{r gf-props}
#| layout-ncol: 2
gf_props(~substance, fill = ~sex, data = HELPrct)
gf_props(~substance, fill = ~sex, data = HELPrct, denom = ~ x)
```


## Labeling plots

Often the defaults labels are not ideal for publication purposes. You can add titles and captions
and change the labeling of variables using `gf_labs()`.

```{r}
#| label: fig-gf-labs
#| fig-cap: Informative labels and make plots easier to read.
#| fig-width: 8
#| fig-height: 4.5
gf_point(bill_length_mm ~ body_mass_g | island, 
         color = ~ species, data = penguins,
         size = 0.8, alpha = 0.6) |>
  gf_labs(x = "body mass (g)", y = "bill length (mm)", 
          title = "Penguin measurments on 3 islands", caption = "Data Source: palmerpenguins")
```


Notice the `|>` (called the **pipe symbol** and sometimes read "then") in the example above. 
This important and connects the labeling below to the plot above.

## Exporting Plots

You can save plots to files or copy them to the clipboard using the 
**Export** menu in the **Plots** tab.  It is quite simple to copy the 
plots to the clipboard and then paste them into a Word document, for example.
You can even adjust the height and width of the plot first to get it the 
shape you want.  _But there are much better ways to produce documents 
with R graphics in them!_  See the next section.

## Reproducible Documents

Copy-and-paste is a bad workflow for lots of reasons, including:
<!-- begin itemize -->

* It is tedious, unless there is very little to copy and paste.
* It is error-prone -- it's easy to copy to little or too much, or to grab the wrong thing,
or to copy when you want to cut or cut when you want to copy.
* If something changes, you have to start all over.
* You have no record of what you did (unless you are an unusual person who
takes detailed notes about all the copying and pasting).
<!-- end itemize -->
So while copy-and-paste seems easy and convenient, it is not _reproducible_.
Reproducibility is important when projects are large, when it is important to have record of 
exactly what was done, or when the same analysis is applied to multiple data sets (or a data set
that is growing over time).

RStudio  makes it easy to use techniques of reproducible research to create
documents that include text, R commands, R output, and R graphics.

### Quarto 

The simplest version of this uses a format called Quarto.^[A similar, but older, way of doing this uses R Markdown.
If you have used R Markdown before, learning Quarto will be very easy -- they are very similar.]
Quarto is a simple mark up language that allows for a few basic improvements on plain text
(section headers, bulletted lists, numbered lists, bold, italics, etc.).
Quarto adds the ability to mix in the R stuff. (And it has some fancier stuff, like
embedding videos.)
The end product can be an HTML file, a PDF document, even a Word or PowerPoint document. 
HTML is especially good for producing web documents, but it is also useful as preview mode,
even if you eventually render to PDF (or Word).^[You can actually mix in arbitrary HTML and even css, so if you
are good at HTML, you can have quite a bit of control over how things look. But if you do that, some things
won't convert to PDF or Word. Here will will focus on the basics and things that work in 
multiple output formats.]

#### Creating a new document

To create a new Quarto document, go to "File", "New File", then "Quarto document".

![](images/file-new-quarto-document.png){width="40%" fig-align=center}

When you do this, a file editing pane will open with a simple example quarto file inserted.  If
you click on "Render", RStudio  will turn this into an HTML file and
display it for you. Give it a try.  You will be asked to name your file if you
haven't already done so.  If you are using the RStudio  server in a browser,
then your file will live on the server ("in the cloud") rather than on your
computer.

### Three kinds of sections

If you look at the example file you will see that the file has three kinds of
sections.  

#### YAML header

At the top of the document is the YAML (Yet Another Markup Language) header. This is where 
you set things like the author and title for your document and specify certain settings that 
control how the document is processed.

It is important that this section is syntactically correct (mathing quatoation marks, correct indentation, etc.).
If you get an error message with YAML or yaml in it, you will know that something has gone wrong in the YAML
header.

:::{.callout-tip}
#### Fixing YAML errors

If you can't figure out the problem with your YAML header, copy and paste in the YAML from some other document (a previous document you have made or a new one) and edit from there.
:::

#### Text blocks

Some of this file is just normal text (with some styling to
make headers, bold, italics, etc.)

#### Code chunks

The third type of section is an R code chunk.  These are colored differently to
make them easier to see.  You can insert a new code chunk by clicking on the icon 
pictured below.


![](images/insert-r-chunk.png){width="1.2in" fig-align=center}

You can put any R code in these code chunks and the results (text output or graphics) as well
as the R code will be displayed in your HTML file.^[There are options to do things like (a) run R code without displaying it, (b) run R code without
displaying the output, (c) controlling size of plots, etc., etc.
But for starting out, this is really all you need to know.]

#### Source vs Visual view

RStudio provides two different views of Quarto files. The default is the **Visual view**.
This looks a bit like a simplified version of Word. There is a toolbar you can use to 
create bold, italics, headers, etc. 

If you click on **Source** in the upper left corner, you will get a different view.
This will show your documents as Markdown.  You will see that in this view, headers are 
indicated with `#`, `##`, `###`, etc.  `*italics*` turns into *italics*, and `**bold**` turns
into **bold**. 

You can get a list of all of these mark up shortcuts by selecting the "Markdown Quick Reference" in the help
menu.

![](images/markdown-quick-reference.png){width="3.5in" fig-align="center"}

If you type these while in the Visual view, the will be immediately converted over for you.

### Quarto files must be self-contained {-}

Quarto files do not have access to things you have done in your console.  (This is good, else 
your document would change based on things not in the file.)  This means that you must explicitly
load any data or packages that you use _in the Quarto file_. In this class,
this means that most of your Quarto files will have a chunk near the beginning that 
includes

````
```{{r}}
#| include: false
library(mosaic)
```
````

The special `#| include: false` comments tells Quarto to run the code, but not to include anything 
in your document. That way you don't have to see all of the package loading messages in your document.

<!-- If you use one of the RMarkdown templates provided,  -->
<!-- this (and some other things) will be included in the template and save you some time. -->

<!-- \iffalse -->
<!-- \subsubsection{Creating an R Markdown document} -->
<!-- To create an R Markdown document, choose ``File", then ``New File", then ``R Markdown".  The file -->
<!-- will open with a template already loaded.   Take a quick look and you will see that most  -->
<!-- of this is easy to read.  You can see some text with a few extra symbols thrown in here and  -->
<!-- there and some chunks of \R\ code. -->
<!-- Now click on the "knit HTML" button and this document will be converted to HTML. -->

<!-- To create your own content, simply delete out the things you don't want or need -->
<!-- and replace them with your own content.  If you forget the markup, there is a help button -->
<!-- that will lead you to a quick reference guide.  To add a chunk of \R\ code, click on  -->
<!-- ``Chunk" and then ``Insert Chunk" and put your \R\ code inside the chunk. -->

<!-- In addition to knitting the document to HTML, you can do a number of other things that will -->
<!-- make your work more efficient.  In the ``Chunk" menu, you can choose to run a single chunk  -->
<!-- or all the chunks.  This will execute your commands in the console so you can make sure  -->
<!-- your \R\ code is working one chunk at a time.  There is also a ``run" button that allows you -->
<!-- to run just one line from within a chunk. -->

<!-- \subsubsection{R Markdown files do not have access to the console environment} -->
<!-- One thing you need to remember about R Markdown documents is that the file must be self-contained. -->
<!-- This ensures that the document is portable.  It also means that the document does not have  -->
<!-- access to the things in your console environment.  All data must be loaded in the file.   -->
<!-- Similarly, all packages you use must also be loaded in the file.  If you start getting messages  -->
<!-- about objects not being found, one possible cause is that you have forgotten to get some  -->
<!-- data or some package loaded inside your file.  (Typos are another cause for these messages --  -->
<!-- check your spelling and capitalization.) -->
<!-- \fi -->

### Chunk options

Quarto provides a number of chunk options that control how R code is processed.
You can use them to do things like:

* run the code without displaying it (good for polished reports -- your client doesn't want to see the code)
* show the code without running it -- mainly useful for demonstration purposes
* set the size and alignment of graphics

You can set default values for the chunk options and you can also override them in individual
chunks. See <https://quarto.org/docs/computations/execution-options.html> for more information about 
chunk options.

The default plots are often bigger than required. You can adjust this by sitting the 
`fig-width` and `fig-height` chunk options. They can be adjusted as necessary.

```{r}
#| echo: fenced
#| fig-width: 4
#| fig-height: 3
#| fig-align: center
gf_histogram(~ Duration, data = oldfaith)
```
```{r}
#| echo: fenced
#| fig-width: 8
#| fig-height: 2
#| fig-align: center
gf_histogram(~ Duration, data = oldfaith)
```

You can set default sizes for the entire document by putting them in your YAML header at the top
of the document:

```{yaml}
#| eval: false
format:
  html:
    fig-width: 8
    fig-height: 2
    fig-align: center
  pdf:
    fig-width: 4
    fig-height: 3
    fig-align: center
```


<!-- ### knitr/latex -->
<!-- There is another system that produces PDFs by combining \LaTeX{} and R This is the system -->
<!-- used to create this document and it gives much more control over paper-like formatting.  The -->
<!-- quality is good enough for professional publishing.  If you already know \LaTeX{} it is very -->
<!-- easy to learn.  If you don't know \LaTeX{} then you need to learn the basics of \LaTeX{} to get -->
<!-- going, but it isn't very difficult. -->

<!-- R code and output can be copied and pasted as well.  It's best to use a  -->
<!-- fixed width font (like Courier) for R code so that things align properly. -->

<!-- Note:  RStudio  provide some nice utilities for creating documents that include -->
<!-- text, code, graphics, and statistical analyses all in one document.  That's how this  -->
<!-- document was produced.  The simpler of these is called RMarkdown.  The resulting file -->
<!-- will be an HTML file with embedded plots.  You can gain more control over the output -->
<!-- by using `knitr` which provides a way to combine $\LaTeX$ and R in a single -->
<!-- document.  The resulting document in this case is a high quality PDF -->

<!-- The block below should be commented out -->

## A Few Bells and Whistles for Plotting

There are lots of arguments that control how plots look.  Here are just a
few examples, some of which we have already seen.

<!--  ### auto.key -->
<!--  <span style="color:brown">auto.key = TRUE</span> turns on a simple legend for the grouping variable.   -->
<!--  (There are ways to have more control, if you need it.) -->
<!--  <<iris-xyplot-key,cache = TRUE,fig.width = 2.6,fig.height = 2.4>>= -->
<!--  xyplot(Sepal.Length ~ Sepal.Width, groups = Species, data = iris,  -->
<!--  	auto.key = TRUE)    -->
<!--  ```
 -->

### alpha, size

Sometimes it is nice to have elements of a plot be partly transparent.  When
such elements overlap, they get darker, showing us where data are "piling up."
Setting the `alpha` argument to a value between 0 and 1 controls the
degree of transparency: 1 is completely opaque, 0 is invisible.  The
`size` argument controls the size of lines and points.

Here is another example using data on 150 iris plants of three species.

```{r }
#| label: fig-iris-alpha
#| fig-cap: 150 iris plants from 3 species.
#| fig.width: 6 
#| fig.height: 3.5
gf_point(Sepal.Length ~ Sepal.Width, color = ~ Species, data = iris, 
	alpha = .6, size = 1.8) 
```


### title, subtitle, caption, xlab, ylab {-}

You can add a title or subtitle, or change the default labels of the axes.

```{r }
#| label: fig-iris-xyplot-text
#| fig-cap: We can add labels using `title`, `subtitle`, `xlab`, and `ylab`. (Using `gf_labs()` is another way to do this.)
#| fig.width: 6 
#| fig.height: 3.5
gf_point(Sepal.Length ~ Sepal.Width, color = ~Species, data = iris, 
	title = "Some Iris Data",
	subtitle = "(R. A. Fisher analysized this data in 1936)",
	caption = "Source: R's built-in iris data set",
	xlab = "sepal width (cm)",
	ylab = "sepal length (cm)",
	alpha = .6 
)
```



#### linetype, linewidth, fill, shape {-}

These can be used to change the line type, line width, plot symbol, and color of filled in regions.
<!-- To specify multiples (one for each group), use the `c()` function (see below). -->

```{r }
#| label: fig-pch-lwd-lty
#| fig.width: 5
#| fig.height: 1.5
#| fig-cap: "Examples using `linetype` and `fill`."
#| fig-subcap:
#|   - "Mapping linetype"
#|   - "Setting linetype"
#|   - "Use fill, rather than color, for filled in regions." 
#| layout-ncol: 1
gf_dens( ~age, data = HELPrct, color = ~ sex, linetype = ~ sex)
gf_dens( ~age, data = HELPrct, color = ~ sex, linetype = "dotted")
gf_histogram( ~ age, data = HELPrct, fill = 'steelblue')
```

You can see a list of the hundreds of available color names using `colors()`:

```{r colors, eval = FALSE}
colors()
```

<!-- ### Setting some defaults -->

<!-- Default settings for graphics properties can be set as follows: -->

<!-- ```{r } -->
<!-- #| label: fig-fontsize -->
<!-- #| fig-cap: "" -->
<!-- #| layout-ncol: 1 -->
<!-- theme_set(theme_classic(base_size = 6))    # base size for text is 6 point; classic theme. -->
<!-- gf_dens( ~age, data = HELPrct, color = ~ sex, linetype = "dashed") -->
<!-- theme_set(theme_bw(base_size = 8))     -->
<!-- gf_dens( ~age, data = HELPrct, color = ~ sex, linetype = "dashed") -->
<!-- ``` -->

## Getting Help in RStudio

### The RStudio  help system
There are several ways to get RStudio  to help you when you forget something.
Most objects in packages have help files that you can access by typing something 
like:

```{r help-questionmark,eval = FALSE,tidy = FALSE}
?bargraph
?histogram
?HELPrct
```

You can search the help system using

```{r help-GR, eval = FALSE}
help.search('Grand Rapids')    # Does R know anything about Grand Rapids?
```

This can be useful if you don't know the name of the function or data set you 
are looking for.

### Tab completion

As you type the name of a function in RStudio  you can hit the tab key and it
will show you a list of all the ways you could complete that name, and after
you type the opening parenthesis, if you hit the tab key, you will get a list
of all the arguments and (sometimes) some helpful hints about what they are.)

### History

If you know you have done something before, but can't remember how, you can
search your history.  The history tab shows a list of recently executed
commands.  There is also a search bar to help you find things from longer ago.

### Error messages

When things go wrong, R tries to help you out by providing an error message.
If you can't make sense of the message, you can try copying and pasting your
command and the error message and sending to me in an email.  One common error
message is illustrated below.

```{r error-message, error = TRUE}
fred <- 23
frd
```

The object `frd` is not found because it was mistyped.  It should have
been `fred`.  If you see an "object not found" message, check your
typing and check to make sure that the necessary packages have been loaded.

## Graphical Summaries -- Important Ideas

### The Most Important Template

The plots we have created have all followed a single template

![The most important template](images/most-important-template.png){width='75%'}

We will see this same template used again for numerical summaries and linear and non-linear 
modeling as well, so it is is important to master it.
To use it, you just fill in the boxes with the information for your particular task.

<!-- begin itemize -->

* `goal`: The name of the function generally describes your goal, 
		the thing you want the computer to produce for you.  In the case of plotting,
		it is the name of the plot.  When we do numerical summaries it will be the 
		name of the numerical summary (mean, median, etc.).
* `formula`: For plotting, the formula describes which variables are 
		used on the x-axis, the y-axis and for conditioning.  The general scheme is `y ~ x | z`
		where `z` is the conditioning variable.  Sometimes `y` or `z` 
		are missing (but the right-hand side `x` must always be included in a formula).
* `mydata:` A data frame must be given in which the variables mentioned in
		the formula can be found.  Variables not found there will be looked for in the 
		enclosing environment.  Sometimes we will take advantage of this to avoid creating
		a temporary data frame just to make a quick plot, but generally it is best to have
		all the information inside a data frame.
* `...` There are many optional arguments to control sizes, colors, etc.
	 We will introduce these as they are needed, but several examples have been 
	 given in this chapter as well. Consult the help files for assistance.
		
<!-- end itemize -->

Just fill in the boxes and get your plot.

### Patterns and Deviations from Patterns

The goal of a statistical plot is to help us see 
<!-- begin itemize -->

* potential patterns in the data, and 
* deviations from those patterns.
<!-- end itemize -->

### Different Plots for Different Kinds of Variables

Graphical summaries can help us see the _distribution_ of a variable 
or the _relationships_ between two (or more) variables.  The type of plot
used will depend on the kinds of variables involved.
There is a nice summary of these on page~48.  You can use `demo()` to see how
to get R to make the plots in this section.

Later, when we do statistical analysis, we will see that the analysis we use will 
also depend on the kinds of variables involved, so this is an important idea.

### Side-by-side Plots and Overlays Can Reveal Importance of Additional Factors

The `ggformula` graphics plots make it particularly easy to generate plots that 
divide the data into groups and either produce a panel for each group (using |!)
or display each group in a different way (different colors or symbols, using 
the `groups` argument).  These plots can reveal the 
possible influence of additional variables -- sometimes called covariates.

### Area = (relative) frequency

Many plots are based on the key idea that our eyes are good at comparing areas.  Plots 
that use area (e.g., histograms, mosaic plots, bar charts, pie charts) should always obey
this principle

:::{.center}
Area $=$ (relative) frequency
:::

Plots that violate this principle can be deceptive and distort the true nature
of the data.

<!-- % \subsubsection*{An Example: Histogram with unequal bin widths} -->
<!-- %  -->
<!-- % It is possible to make histograms with bins that have different widths. -->
<!-- % But in this case it is important that the height of the bars is chosen so  -->
<!-- % that area (\emph{NOT height}) is proportional to frequency.   -->
<!-- % Using height instead of area would distort the picture. -->
<!-- %  -->
<!-- % When unequal bin sizes are specified, \function{histogram()} by default chooses -->
<!-- % the density scale: -->
<!-- %  -->
<!-- % <<hist-unequal-bins,fig.width = 3,fig.height = 2>>= -->
<!-- % gf_histogram( ~ Sepal.Length, data = iris, breaks = c(4,5,5.5,5.75,6,6.5,7,8,9)) -->
<!-- % @ -->
<!-- % The density scale is important. -->
<!-- % It tells \R\ to use a scale such that  -->
<!-- % the area (height $\times$ width) of the rectangles is equal to the relative frequency. -->
<!-- % For example, the bar from 5.0 to 5.5 has width $\frac12$ and height about $0.36$, so  -->
<!-- % the area is $0.18$, which means approximately 18\% of the sepal lengths are  -->
<!-- % between 5.0 and 5.5. -->
<!-- %  -->
<!-- %  -->
<!-- % It would be incorrect to choose \option{type = "count"} or \option{type = "proportion"} since -->
<!-- % this distorts the picture of the data.  Fortunately, \R\ will warn you if you try: -->
<!-- % <<hist-unequal-bins-bad-echo,fig.width = 3,fig.height = 2,eval = FALSE>>= -->
<!-- % histogram( ~ Sepal.Length, data = iris, breaks = c(4,5,5.5,5.75,6,6.5,7,8,9), type = 'count') -->
<!-- % @ -->
<!-- % <<hist-unequal-bins-bad,fig.width = 3,fig.height = 2,echo = FALSE>>= -->
<!-- % trellis.par.set(theme = col.fastR2(bw = T)) -->
<!-- % histogram( ~ Sepal.Length, data = iris, breaks = c(4,5,5.5,5.75,6,6.5,7,8,9),type = "count") -->
<!-- % trellis.focus('panel',1,1) -->
<!-- % grid.text(y = .7,'Never do this!', gp = gpar(col = 'red',cex = 2,alpha = .6)) -->
<!-- % trellis.unfocus() -->
<!-- % trellis.par.set(theme = col.mosaic()) -->
<!-- % @ -->
<!-- %  -->
<!-- % Notice how different this looks.  Now the heights are equal to the relative -->
<!-- % frequency, but this makes the wider bars have too much area. -->


## Exercises

In your solutions to these exercises
include both the plots and the code you used to make them as well as any
required discussion.  Once you get the plots figured out, feel free to 
use some of the bells and whistles to make the plots even better.

:::{.problem #exr-oldfaith}
**Old Faithful**

Create a scatterplot using the two variables in the `oldfaith`
data frame (available in the `alr4` package).
What do we learn about Old Faithful eruptions from this plot?
:::

:::{.problem #exr-CPS85}
**CPS85**

Where do the data in the `CPS85` data frame (in the 
`mosaic` package) come from?
What are the observational units? How many are there?
:::

:::{.problem #exr-CPS85-quant}
**Quantitative variable in CPS85**

Choose a quantitative variable that interests you in the `CPS85`
data set.  Make an appropriate plot and comment on what you see.
:::

:::{.problem #exr-CPS85-cat}
**Categorical variable in CPS85**

Choose a categorical variable that interests you in the `CPS85`
data set.  Make an appropriate plot and comment on what you see.
:::

:::{.problem #exr-CPS85-2-vars}
**Multiple variables in CPS85**

Create a plot that displays two or more variables from the 
`CPS85` data. At least one should be quantitative and at least one should be categorical.
Comment on what you can learn from your plot.
:::

:::{.problem #exr-mpg}
**mpg**

Where do the data in the `mpg` data frame (in the 
`ggplot2` package) come from?  What are the observational 
units?  How many are there?
:::

:::{.problem #exr-mpg-quant}
**Quantitative variable in mpg**

Choose a quantitative variable that interests you in the `mpg`
data set.  Make an appropriate plot and comment on what you see.
:::

:::{.problem #exr-mpg-cat}
**Categorical variable in mpg**

Choose a categorical variable that interests you in the `mpg`
data set.  Make an appropriate plot and comment on what you see.
:::

:::{.problem #exr-mpg-multivar}
**Multiple variables in mpg**

Create a plot that displays two or more variables from the `mpg` data. 
At least one should be quantitative and at least one should be categorical.
Comment on what you can learn from your plot.
:::

:::{.problem #exr-fires}
**Fires**

The file at <https://rpruim.github.io/Engineering-Statistics/data/Fires.csv>
is a csv file containing data on wild lands fires in the US over a number of years.
You can load this data one of two ways.

* Go to the **Environment** tab, select **Import Dataset**, choose **From Text** (either option will due) 
and follow the instructions.
* Use the following command in R 
		
```{r }
url <- "https://rpruim.github.io/Engineering-Statistics/data/Fires.csv"

# equivalent to "From Text (base)" in RStudio
Fires <- read.csv(url)

# alternative method -- equivalent to "From Text (readr)" in RStudio
library(readr)
Fires <- read_csv(url)
```


You can also use either of these methods to read from a file rather than from a
web URL, so this is a good way to get your own data into R 

a. The source for these data claim that data before a certain year should not be compared
		to data from after that year because the older data were computed a different way and
		are not considered as reliable.  What year is the break point?  Use graphs of the data 
		over time to estimate when something changed.
b. Create a data set that contains only the data from the new data regime (based on your answer in the previous problem).
   You can trim the data to just the subset you want using `filter()`.  For 
	 example, to get just the subset of years since 1966, you could use the code below.
   (Be sure to save the result with a new new name if you want to keep the original data available.)
		
```{r}
Fires2 <-               # create a new data set called Fires2
  Fires |>              # start with all the Fires data
  filter(Year > 1966)   # then filter to keep only years after 1966
```

c. Using only the data from the smaller set you just created, 
how would you describe what is happening with fires over time?

:::

:::{.problem #exr-i1-and-i2}
**What are i1 and i2?**

Use R s help system to find out what the `i1` and `i2` 
variables are in the `HELPrct` data frame.  Make histograms
for each variable and comment on what you find out.  How would you describe
the shape of these distributions?  Do you see any outliers (observations
that don't seem to fit the pattern of the rest of the data)?
:::

:::{.problem #exr-i1-and-i2-by-sex}
**i1 and i2 among men and among women**

Compare the distribution of `i1` among men vs. among women.  Do the same for `i2`.
:::

:::{.mysolution}

```{r }
gf_dens( ~max_drinks, color = ~ sex, data = HELPrct )
gf_dens( ~avg_drinks, color = ~ sex, data = HELPrct )
```

:::

:::{.problem #exr-i1-and-i2-by-substance}
**i1 and i2 among different treatment groups**

Compare the distributions of `i1` among the three `substance` groups.
Do the same for `i2`.
:::

:::{.mysolution}

```{r }
gf_dens( ~i1, color = ~ substance, data = HELPrct )
gf_dens( ~i2, color = ~ substance, data = HELPrct )
```

```{r }
gf_dens( ~i1 | sex, color = ~ substance, data = HELPrct )
gf_dens( ~i2 | sex, color = ~ substance, data = HELPrct )
```

```{r }
gf_point( i2 ~ i1, color = ~ sex, data =  HELPrct, alpha = .6, size = .6 )
```

:::

:::{.problem #exr-snow-gr}
**Snow in GR**

The `SnowGR` contains historical data on snowfall in Grand Rapids, MI.
The snowfall total for January, 2014 was 36.6 inches.

a. Create a histogram of January snowfall totals.  How unusual is 36.6 inches of 
snow in January?

b. If there is a lot of snow in January, should we expect to have unusually much
or little snow in February?  Make a scatter plot comparing January and February
snowfall totals and comment on what you see there.
:::

:::{.mysolution}

```{r }
gf_histogram( ~ Jan, data = SnowGR)
```

36.6 inches is pretty high, but not the highest ever for a January.  Certainly well above average.

```{r }
gf_point(Feb ~ Jan, data = SnowGR)
```

There is no clear trend.  Sometimes the snow keeps on coming, but a heavy snow
January could be followed by either a heavy or light snow February.
:::
